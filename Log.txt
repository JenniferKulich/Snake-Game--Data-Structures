March 17 (Sunday):
	* Downloaded Hinker's startup code
	* Made a new repository (csc315_sp2019_project3)
	* Made first commit of the startup code source

March 18 (Monday):
	* Got the new tar file
	* Got the startup code compiling and running
	* Tried messing around with the code. Have code written for the zig-zag
		pattern- Hamilton patter that just works for even height board
	* Created a zig-zag pattern for an odd board. Works pretty well and long as
		there aren't a lot of blocks in the second to top row.
	* I know I could condense my code a lot more, but I know I can't keep using
		this strategy- I only used it to get used to the code base and how things
		worked. Works well enough for checkpoint 1.

March 19 (Tuesday):
	* Cleaned up the code I wasn't using
	* Waiting to change strategy until we go over more stuff in class

March 23 (Saturday):
	* fixed the driver issue
	* ran the average score
	* going to try to implement a graph

March 24 (Sunday)
	* Add the graph class from the homework.

March 25 (Monday)
	* Added code for BFS that we looked at in class so I can possibly use it later
	* Tried using the BFS class from in class to make sure I could implement it
	* Not quite sure how to be able to use the path list in order to make the
	  moves - I think I could create a constant list in the player class, but I'm
		not sure. I'll be asking Hinker tomorrow

March 26 (Tuesday)
	* Worked on implementing BFS for my snake to use
	* The BFS algorithm won't work because the snake will eventually cut off
		paths to the food while taking the shortest path. However, this will avoid
		obstacles and will hopefully take a smart-ish path. I may be able to use
		this later as part of my final algorithm.

March 27 (Wednesday)
	* Added a graph constructor to the BFS code- that's what was wrong yesterday
	* Rewrote the graph constructor to add the edges correctly. Still working out
		the bugs for BFS.
	* I may possibly write a more simple path finding code for Friday if I don't
		get very far with BFS.
	* Dalton helped look at my code and determine that my BFS constructor wasn't
		actually using the headSpot number, so I had to initialize it

March 28 (Thursday)
	* For some reason, there was a wrong calculation for the movement, and I
		realized I had already done a index calculation and I could just use that.
		Now the snake just runs into itself.
	* I'm thinking of doing something like a BFS/DFS combination. This would help
		the snake not trap itself, and if it does, it'll move around until a
		possible path is cleared.
	* BFS now runs except it will seg fault randomly- 1 to 4 times per 100 rounds.
	* Averages around 30 to 35 with and without obstacles.
	* The snake will run into itself if it thinks there is a path, so I'll have
		to make sure that it doesn't think that it's a path.
	* Will need to add a loitering algorithm if there is no path to the food.

April 1 (Monday)
	* Had a busy weekend and wasn't able to work on the code at all
	* Should add a check to make sure snake isn't trapping itself. I'll probably
		add some check to make sure it would be able to find its tail again based on
		the path. If a path cannot be found, it'll move around in a smart random
		pattern. I had seen Dalton's move in a zig-zag sort of patter, so that might
		be an option. Either that, or do something like a DFS move.
	* For when there is no path to the food, I may try findind a path to the
		tail and go there in hopes on opening up a way to get to the food.
	* I'm going to try implementing DFS for when the snake would trap itself but
		make the target its tail.
	* Got DFS working, I'm pretty sure. I ran the driver for the obstacle map,
		and my average is 37 with a max of 73, so I assume since my average went up,
		the DFS is working.
	* I'm trying to think how a weighted graph could possibly be implemented. I
		found an implementation where it weighted the adjacent tiles based on how
		far they were from the food tile. I may try something like this once we go
		over weighted graphs more.
		Here's the video for it: https://www.youtube.com/watch?v=-L-WgKMFuhE

April 2 (Tuesday)
	* So the DFS I implemented yesterday wouldn't work at all, and that was
		because if there's no BFS path to the food, there wouldn't be a DFS path.
		I thought about writing a function that would find the tail of the snake and
		try going there. Then I realized that I didn't know how to find the tail of
		the snake and couldn't access the queue for the snake tail. Instead, wrote a
		function that would make valid random moves until a path to the food could
		be found. This will probably trap the snake a some points, but I'm hoping
		that it will be enough to improve my score by a little bit until I can talk
		to someone.
	* The random moves makes my snake kill itself a lot (will core dump), but the
		average on a board with obstacles a 38 with a max of 93. I talked to Dalton,
		and he used the original Manhattan code that Hinker gave us to make
		'random' moves. He also checked to make sure that the move the snake was
		making would not end the game. I'm going to try this.
	* Added documentation and cleaned up the code
	* Average for obstacles is now 41 with a high of 93

April 3 (Wednesday)
	* For some reason, I found that my code wasn't working the way I wanted it to
		when the Manhattan function was called. I spent a lot of time trying to
		debug it, thinking that I just did it wrong. I then realized that this
		only happened when the snake was completely surrounded and trapped. My code
		should have been returning NONE as the move, but it was returning a move and
		causing the core dumps. After debugging for 2-3 hours, I asked Dalton to
		look at my code. He found my error when I was building the graph class.
		Essentially, I was accessing a map item that wasn't there thus causing the
		core dump.
	* Tried what Dalton was talking about, but it made my code very slow and
		it wasn't working properly, so I reverted back to what I had before, and
		added something more simples. It doesn't core dump anymore and it doesn't
		run as slow.
	* Things to do tomorrow: clean up code and time it

April 4 (Thursday)
	* Cleaned up code that I didn't need
	* I want to try to implement a weighted graph next and then try to implement the
		algorithm from the video mentioned above. I think this will help make my snake a
		a little smarter.
	* Dijkstra's algorithm looks to be very similar to what the video was showing, so I
		may wait until tomorrow when Hinker shows the code to actually implement anything.
	* Going to add a heap class since that's what we talked about using in class for
		Dijkstra's, and that's what the video was showing to use to optimize their code
	* Added the code from the video to some files just so I can mess around with it and
		see how stuff works. I'm not quite sure how it implements things yet- especially
		the path, and I'm not sure what happens if there's little dead end paths. This
		looks like a more complicated version of Dijkstra's. I'm naming it
		'complicated Dijkstra'

	April 7 (Sunday)
		* Worked on trying to get complicated Dijkstra to work. I spent
			quite some time just debugging  it and trying not to get any errors or
			warning. This didn't help because in the video, a list was used, but I
			realized that using a vector would be much better since I needed random
			access. Looking back, a list would have a smaller complexity (an insertion
			in the front for a vector is O(n) while a list would have been O(1)). I
			should definitely change this! However, I also know that for this
			algorithm, it would much cheaper to use a heap, so I may not convert
			everything to lists.
		* Complicated Dijkstra will seg fault when implemented, so I'll have to work
			on that before I start using a heap. I probably don't need to, but I want
			to make sure that I understand what's going on first.
		* I'll investigate tomorrow why this is happening.

	April 8 (Monday)
		* Integrated the code from Hinker so that the graph will not produced a
			biconnected graph.
		* Deleted my complicated Dijkstras code. I realized that it was just not
			going to work- there were too many things wrong with it, and if Hinker was
			going to put up the code for it, I didn't think it was worth my time.
			Also, what I was doing didn't make a weighted graph class, and at this
			point, I would much rather use that, but I'm not sure how I would put it
			in with my code. Also, it was horribly inefficient especially using
			vecotrs.
